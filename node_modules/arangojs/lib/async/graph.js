"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const collection_1 = require("./collection");
class GraphVertexCollection extends collection_1.BaseCollection {
    constructor(connection, name, graph) {
        super(connection, name);
        this.type = collection_1.Types.DOCUMENT_COLLECTION;
        this.graph = graph;
        this._gharial = this._api.route(`/gharial/${this.graph.name}/vertex`);
    }
    _documentPath(documentHandle) {
        return `/document/${this._documentHandle(documentHandle)}`;
    }
    async vertex(documentHandle) {
        const res = await this._gharial.get(`/${this._documentHandle(documentHandle)}`);
        return res.body.vertex;
    }
    async save(data, opts) {
        const res = await this._gharial.post(this.name, data, opts);
        return res.body.vertex;
    }
    async replace(documentHandle, newValue, opts = {}) {
        const headers = {};
        if (typeof opts === "string") {
            opts = { rev: opts };
        }
        if (opts.rev) {
            let rev;
            ({ rev } = opts, opts = __rest(opts, ["rev"]));
            headers["if-match"] = rev;
        }
        const res = await this._gharial.put(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
        return res.body.vertex;
    }
    async update(documentHandle, newValue, opts = {}) {
        const headers = {};
        if (typeof opts === "string") {
            opts = { rev: opts };
        }
        if (opts.rev) {
            let rev;
            ({ rev } = opts, opts = __rest(opts, ["rev"]));
            headers["if-match"] = rev;
        }
        const res = await this._gharial.patch(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
        return res.body.vertex;
    }
    async remove(documentHandle, opts = {}) {
        const headers = {};
        if (typeof opts === "string") {
            opts = { rev: opts };
        }
        if (opts.rev) {
            let rev;
            ({ rev } = opts, opts = __rest(opts, ["rev"]));
            headers["if-match"] = rev;
        }
        const res = await this._gharial.delete(`/${this._documentHandle(documentHandle)}`, opts, headers);
        return res.body.removed;
    }
}
exports.GraphVertexCollection = GraphVertexCollection;
class GraphEdgeCollection extends collection_1.EdgeCollection {
    constructor(connection, name, graph) {
        super(connection, name);
        this.type = collection_1.Types.EDGE_COLLECTION;
        this.type = collection_1.Types.EDGE_COLLECTION;
        this.graph = graph;
        this._gharial = this._api.route(`/gharial/${this.graph.name}/edge`);
    }
    async edge(documentHandle) {
        const res = await this._gharial.get(`/${this._documentHandle(documentHandle)}`);
        return res.body.edge;
    }
    async save(data, fromId, toId, opts) {
        if (fromId !== undefined) {
            if (toId !== undefined) {
                data._from = this._documentHandle(fromId);
                data._to = this._documentHandle(toId);
            }
            else {
                opts = fromId;
            }
        }
        const res = await this._gharial.post(this.name, data, opts);
        return res.body.edge;
    }
    async replace(documentHandle, newValue, opts = {}) {
        const headers = {};
        if (typeof opts === "string") {
            opts = { rev: opts };
        }
        if (opts.rev) {
            let rev;
            ({ rev } = opts, opts = __rest(opts, ["rev"]));
            headers["if-match"] = rev;
        }
        const res = await this._gharial.put(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
        return res.body.edge;
    }
    async update(documentHandle, newValue, opts = {}) {
        const headers = {};
        if (typeof opts === "string") {
            opts = { rev: opts };
        }
        if (opts.rev) {
            let rev;
            ({ rev } = opts, opts = __rest(opts, ["rev"]));
            headers["if-match"] = rev;
        }
        const res = await this._gharial.patch(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
        return res.body.edge;
    }
    async remove(documentHandle, opts = {}) {
        const headers = {};
        if (typeof opts === "string") {
            opts = { rev: opts };
        }
        if (opts.rev) {
            let rev;
            ({ rev } = opts, opts = __rest(opts, ["rev"]));
            headers["if-match"] = rev;
        }
        const res = await this._gharial.delete(`/${this._documentHandle(documentHandle)}`, opts, headers);
        return res.body.removed;
    }
}
exports.GraphEdgeCollection = GraphEdgeCollection;
class Graph {
    constructor(connection, name) {
        this.name = name;
        this._connection = connection;
        this._api = this._connection.route("/_api");
        this._gharial = this._api.route(`/gharial/${this.name}`);
    }
    async get() {
        const res = await this._gharial.get();
        return res.body.graph;
    }
    async create(properties = {}, opts) {
        const res = await this._api.post("/gharial", Object.assign({}, properties, { name: this.name }), opts);
        return res.body.graph;
    }
    async drop(dropCollections = false) {
        const res = await this._gharial.delete({ dropCollections });
        return res.body.removed;
    }
    vertexCollection(collectionName) {
        return new GraphVertexCollection(this._connection, collectionName, this);
    }
    async listVertexCollections(opts) {
        const res = await this._gharial.get("/vertex", opts);
        return res.body.collections;
    }
    async vertexCollections(opts) {
        const names = await this.listVertexCollections(opts);
        return names.map((name) => new GraphVertexCollection(this._connection, name, this));
    }
    async addVertexCollection(collection) {
        if (collection_1.isArangoCollection(collection)) {
            collection = collection.name;
        }
        const res = await this._gharial.post("/vertex", {
            collection
        });
        return res.body.graph;
    }
    async removeVertexCollection(collection, dropCollection = false) {
        if (collection_1.isArangoCollection(collection)) {
            collection = collection.name;
        }
        const res = await this._gharial.delete(`/vertex/${collection}`, {
            dropCollection
        });
        return res.body.graph;
    }
    edgeCollection(collectionName) {
        return new GraphEdgeCollection(this._connection, collectionName, this);
    }
    async listEdgeCollections() {
        const res = await this._gharial.get("/edge");
        return res.body.collections;
    }
    async edgeCollections() {
        const names = await this.listEdgeCollections();
        return names.map((name) => new GraphEdgeCollection(this._connection, name, this));
    }
    async addEdgeDefinition(definition) {
        const res = await this._gharial.post("/edge", definition);
        return res.body.graph;
    }
    async replaceEdgeDefinition(definitionName, definition) {
        const res = await this._gharial.put(`/edge/${definitionName}`, definition);
        return res.body.graph;
    }
    async removeEdgeDefinition(definitionName, dropCollection = false) {
        const res = await this._gharial.delete(`edge/${definitionName}`, {
            dropCollection
        });
        return res.body.graph;
    }
    async traversal(startVertex, opts) {
        const res = await this._api.post("/traversal", Object.assign({}, opts, { startVertex, graphName: this.name }));
        return res.body.result;
    }
}
exports.Graph = Graph;
//# sourceMappingURL=graph.js.map