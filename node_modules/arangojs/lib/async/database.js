"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const aql_query_1 = require("./aql-query");
const collection_1 = require("./collection");
const connection_1 = require("./connection");
const cursor_1 = require("./cursor");
const graph_1 = require("./graph");
const btoa_1 = require("./util/btoa");
const multipart_1 = require("./util/multipart");
function colToString(collection) {
    if (collection_1.isArangoCollection(collection)) {
        return String(collection.name);
    }
    else
        return String(collection);
}
class Database {
    constructor(config) {
        this._connection = new connection_1.Connection(config);
        this._api = this._connection.route("/_api");
        this.useBasicAuth();
    }
    get name() {
        return this._connection.getDatabaseName() || null;
    }
    route(path, headers) {
        return this._connection.route(path, headers);
    }
    async acquireHostList() {
        if (!this._connection.getDatabaseName()) {
            throw new Error("Cannot acquire host list with absolute URL");
        }
        const res = await this._api.request({
            path: "/cluster/endpoints"
        });
        const urls = res.body.endpoints.map((endpoint) => endpoint.endpoint);
        this._connection.addToHostList(urls);
    }
    // Database manipulation
    useDatabase(databaseName) {
        this._connection.setDatabaseName(databaseName);
        return this;
    }
    useBearerAuth(token) {
        this._connection.setHeader("authorization", `Bearer ${token}`);
        return this;
    }
    useBasicAuth(username = "root", password = "") {
        this._connection.setHeader("authorization", `Basic ${btoa_1.btoa(`${username}:${password}`)}`);
        return this;
    }
    async get() {
        const res = await this._api.get("/database/current");
        return res.body.result;
    }
    async createDatabase(databaseName, users) {
        const res = await this._api.post("/database", {
            users,
            name: databaseName
        });
        return res.body;
    }
    async listDatabases() {
        const res = await this._api.get("/database");
        return res.body.result;
    }
    async listUserDatabases() {
        const res = await this._api.get("/database/user");
        return res.body.result;
    }
    async dropDatabase(databaseName) {
        const res = await this._api.delete(`/database/${databaseName}`);
        return res.body;
    }
    // Collection manipulation
    collection(collectionName) {
        return new collection_1.DocumentCollection(this._connection, collectionName);
    }
    edgeCollection(collectionName) {
        return new collection_1.EdgeCollection(this._connection, collectionName);
    }
    async listCollections(excludeSystem = true) {
        const res = await this._api.get("/collection", { excludeSystem });
        if (this._connection.arangoMajor <= 2) {
            return res.body.collections;
        }
        return res.body.result;
    }
    async collections(excludeSystem = true) {
        const collections = await this.listCollections(excludeSystem);
        return collections.map((data) => collection_1.constructCollection(this._connection, data));
    }
    async truncate(excludeSystem = true) {
        const collections = await this.listCollections(excludeSystem);
        return await Promise.all(collections.map(async (data) => {
            const res = await this._api.put(`/collection/${data.name}/truncate`);
            return res.body;
        }));
    }
    // Graph manipulation
    graph(graphName) {
        return new graph_1.Graph(this._connection, graphName);
    }
    async listGraphs() {
        const res = await this._api.get("/gharial");
        return res.body.graphs;
    }
    async graphs() {
        const graphs = await this.listGraphs();
        return graphs.map((data) => this.graph(data._key));
    }
    async transaction(collections, action, params, options) {
        if (typeof params === "number") {
            options = params;
            params = undefined;
        }
        if (typeof options === "number") {
            options = { lockTimeout: options };
        }
        if (typeof collections === "string") {
            collections = { write: [collections] };
        }
        else if (Array.isArray(collections)) {
            collections = { write: collections.map(colToString) };
        }
        else if (collection_1.isArangoCollection(collections)) {
            collections = { write: colToString(collections) };
        }
        else if (collections && typeof collections === "object") {
            collections = Object.assign({}, collections);
            if (collections.read) {
                if (!Array.isArray(collections.read)) {
                    collections.read = colToString(collections.read);
                }
                else
                    collections.read = collections.read.map(colToString);
            }
            if (collections.write) {
                if (!Array.isArray(collections.write)) {
                    collections.write = colToString(collections.write);
                }
                else
                    collections.write = collections.write.map(colToString);
            }
        }
        const res = await this._api.post("/transaction", Object.assign({ collections,
            action,
            params }, options));
        return res.body.result;
    }
    async query(query, bindVars, opts) {
        if (aql_query_1.isAqlQuery(query)) {
            opts = bindVars;
            bindVars = query.bindVars;
            query = query.query;
        }
        else if (aql_query_1.isAqlLiteral(query)) {
            query = query.toAQL();
        }
        const res = await this._api.post("/cursor", Object.assign({}, opts, { query, bindVars }));
        return new cursor_1.ArrayCursor(this._connection, res.body, res.host);
    }
    // Function management
    async listFunctions() {
        const res = await this._api.get("/aqlfunction");
        return res.body;
    }
    async createFunction(name, code) {
        const res = await this._api.post("/aqlfunction", { name, code });
        return res.body;
    }
    async dropFunction(name, group = false) {
        const res = await this._api.delete(`/aqlfunction/${name}`, { group });
        return res.body;
    }
    // Service management
    async listServices() {
        const res = await this._api.get("/foxx");
        return res.body;
    }
    async installService(mount, source, opts = {}) {
        const { configuration, dependencies } = opts, qs = __rest(opts, ["configuration", "dependencies"]);
        const req = await multipart_1.toForm({
            configuration,
            dependencies,
            source
        });
        const res = await this._api.request({
            method: "POST",
            path: "/foxx",
            body: req.body,
            isBinary: true,
            qs: Object.assign({}, qs, { mount }),
            headers: req.headers
        });
        return res.body;
    }
    async upgradeService(mount, source, opts = {}) {
        const { configuration, dependencies } = opts, qs = __rest(opts, ["configuration", "dependencies"]);
        const req = await multipart_1.toForm({
            configuration,
            dependencies,
            source
        });
        const res = await this._api.request({
            method: "PATCH",
            path: "/foxx/service",
            body: req.body,
            isBinary: true,
            qs: Object.assign({}, qs, { mount }),
            headers: req.headers
        });
        return res.body;
    }
    async replaceService(mount, source, opts = {}) {
        const { configuration, dependencies } = opts, qs = __rest(opts, ["configuration", "dependencies"]);
        const req = await multipart_1.toForm({
            configuration,
            dependencies,
            source
        });
        const res = await this._api.request({
            method: "PUT",
            path: "/foxx/service",
            body: req.body,
            isBinary: true,
            qs: Object.assign({}, qs, { mount }),
            headers: req.headers
        });
        return res.body;
    }
    async uninstallService(mount, opts = {}) {
        await this._api.delete("/foxx/service", Object.assign({}, opts, { mount }));
    }
    async getService(mount) {
        const res = await this._api.get("/foxx/service", { mount });
        return res.body;
    }
    async getServiceConfiguration(mount, minimal = false) {
        const res = await this._api.get("/foxx/configuration", { mount, minimal });
        if (!minimal || !Object.values(res.body).every((value) => value.title))
            return res.body;
        const values = {};
        for (const key of Object.keys(res.body)) {
            values[key] = res.body[key].current;
        }
        return values;
    }
    async updateServiceConfiguration(mount, cfg, minimal = false) {
        const res = await this._api.patch("/foxx/configuration", cfg, {
            mount,
            minimal
        });
        const result = res.body;
        if (minimal ||
            !result.values ||
            !Object.values(result.values).every((value) => value.title)) {
            return result;
        }
        const res2 = await this.getServiceConfiguration(mount, minimal);
        const result2 = res2.body;
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async replaceServiceConfiguration(mount, cfg, minimal = false) {
        const res = await this._api.put("/foxx/configuration", cfg, {
            mount,
            minimal
        });
        const result = res.body;
        if (minimal ||
            !result.values ||
            !Object.values(result.values).every((value) => value.title)) {
            return result;
        }
        const res2 = await this.getServiceConfiguration(mount, minimal);
        const result2 = res2.body;
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async getServiceDependencies(mount, minimal = false) {
        const res = await this._api.get("/foxx/dependencies", { mount, minimal });
        if (!minimal || !Object.values(res.body).every((value) => value.title))
            return res.body;
        const values = {};
        for (const key of Object.keys(res.body)) {
            values[key] = res.body[key].current;
        }
        return values;
    }
    async updateServiceDependencies(mount, cfg, minimal = false) {
        const res = await this._api.patch("/foxx/dependencies", cfg, {
            mount,
            minimal
        });
        const result = res.body;
        if (minimal ||
            !result.values ||
            !Object.values(result.values).every((value) => value.title)) {
            return result;
        }
        const res2 = await this.getServiceDependencies(mount, minimal);
        const result2 = res2.body;
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async replaceServiceDependencies(mount, cfg, minimal = false) {
        const res = await this._api.put("/foxx/dependencies", cfg, {
            mount,
            minimal
        });
        const result = res.body;
        if (minimal ||
            !result.values ||
            !Object.values(result.values).every((value) => value.title)) {
            return result;
        }
        const res2 = await this.getServiceDependencies(mount, minimal);
        const result2 = res2.body;
        if (result.warnings) {
            for (const key of Object.keys(result2)) {
                result2[key].warning = result.warnings[key];
            }
        }
        return result2;
    }
    async enableServiceDevelopmentMode(mount) {
        const res = await this._api.post("/foxx/development", undefined, { mount });
        return res.body;
    }
    async disableServiceDevelopmentMode(mount) {
        const res = await this._api.delete("/foxx/development", { mount });
        return res.body;
    }
    async listServiceScripts(mount) {
        const res = await this._api.get("/foxx/scripts", { mount });
        return res.body;
    }
    async runServiceScript(mount, name, args) {
        const res = await this._api.post(`/foxx/scripts/${name}`, args, { mount });
        return res.body;
    }
    async runServiceTests(mount, opts) {
        const res = await this._api.post("/foxx/tests", undefined, Object.assign({}, opts, { mount }));
        return res.body;
    }
    async getServiceReadme(mount) {
        const res = await this._api.get("/foxx/readme", { mount });
        return res.body;
    }
    async getServiceDocumentation(mount) {
        const res = await this._api.get("/foxx/swagger", { mount });
        return res.body;
    }
    async downloadService(mount) {
        const res = await this._api.request({
            method: "POST",
            path: "/foxx/download",
            qs: { mount },
            expectBinary: true
        });
        return res.body;
    }
    async commitLocalServiceState(replace = false) {
        await this._api.post("/foxx/commit", undefined, { replace });
    }
}
exports.Database = Database;
//# sourceMappingURL=database.js.map